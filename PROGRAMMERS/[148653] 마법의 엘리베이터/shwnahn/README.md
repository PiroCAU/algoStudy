# 사고의 흐름

재귀로 풀어볼까 싶다.

Ex.

2554 = 3000 - 446, (446 = 3000 - 2554)

446 = 400 + 46, (46 = 446 - 400)

46 = 50 - 4,

4 (1의 자리니까 종료)

### 솔루션(1)

숫자가 배열처럼 되었다는 가정하에

    func(숫자, 자릿수):
        if(숫자 = 0): return
        if(자릿수 = 1):
            count += 숫자
            return
        if(숫자[1] < 5):
            next = 숫자 - 숫자[0] * 10^(자릿수-1)
            count += 숫자[0]
            func(next, 자릿수-1)
        else:
            next = (숫자[0]+1) * 10^(자릿수-1) - 숫자
            count += (숫자[0]+1)
            func(next, 자릿수-1)

> 600의 경우 1000 - 400 으로 풀어낼 수 있다. 그런데 내 로직은 600 또는 700으로 고정되기에 한계가 있음.

> 자릿수 아래에서 위로 가는 식으로 고쳐야겠다..

### 솔루션(2)

Bottom up 짜려다가 머리아파서 포기

### 솔루션(3)
솔루션(1) 코드를 유지하고, 맨 윗자리 값에 따라 분기처리 조건 추가

계산 종류 ex. 45
1. 최고자릿수에서 연산하기
   1. 올려서 빼기: 50 - 5 
   2. 그대로 더하기: 40 + 5
2. 한 자리 올려서 빼기 : 100 - 55

**맨 윗자리 수가**

1~4일 때 : (1)

5일 때 : 두 번째 자리수가 0~4이면 (1), 6~9면 (2), 
- 두 번째 자리 수도 5면 (1)이나 (2)나 똑같다.

5~9일 때: (2)

    
    func(숫자):
        if (숫자 = 0) return
        if (숫자.자릿수 = 1):
            count += Math.min(숫자, 10 - 숫자 + 1)
            return
        if (숫자.최고숫자 < 5):
            다음숫자 = cal1(숫자)
        else if (숫자.최고숫자 > 5):
            다음숫자 = cal2(숫자)
        else: // 5의 경우
            if(숫자.둘째숫자 < 5): 다음숫자 = cal1(숫자)
            else: 다음숫자 = cal2(숫자)
        func(다음숫자)

    cal1(숫자):
        if(숫자.둘째숫자 <= 5):
            next = 숫자 - 숫자.둘째숫자 * 10^(자릿수-1)
            count += 숫자.둘째숫자
            return 다음숫자
        else:
            next = (숫자.둘째숫자+1) * 10^(자릿수-1) - 숫자
            count += (숫자.둘째숫자+1)
            return 다음숫자

    cal2(숫자):
        count += 1
        next = 10^(자릿수) - 숫자
        return next

# 어려운 점

# 배운 점

^ 는 거듭제곱이 아니라 XOR 연산자다...!

> Math.pow(10, length - 1)

# 알고리즘
