# 사고의 흐름
이진트리를 수로 표현하기
1. 이진수 저장할 문자열
2. 이진트리에 더미 노드 추가
3. 왼쪽부터 살펴보기 (높이 상관없이)
   - 더미 노드라면 문자열 뒤에 0
   - 아니라면 문자열 뒤에 1
4. 이진수를 십진수로

입력: 이진트리로 만들 수 담은 int[]

출력: 이진트리로 표현가능여부 int[]

### 문제해결 과정

    42 = 32 + 8 + 2 -> 101010 -> 0101010

         1
      1     1
    0   0  0  0

노드 개수가 2^n - 1 이어야 한다. 따라서 필요하다면 패딩

n/2 번째 숫자가 가운데 노드

    010 1 010 -> 1이 가운데 노드. 010/010 으로 분리

서브트리에 대해 다시 나누기

서브트리의 문자 개수가 짝수면? 짝수일 리가 없다.
- 서브트리 만드는 과정:
((2^n-1) - 1) / 2 = 2^n-1) - 1
- 재귀로 반복해도 문제없음.

0인 루트 노드아래에 1이 있으면 false

### 솔루션

1. 숫자를 이진수로 변환
   - 필요하다면 0 패딩
2. n/2 번째 숫자가 가운데 노드
3. 하위 노드 2개 추출
4. 가운데 노드가 0이면 하위 노드 값 확인 T/F
5. 하위 노드가 없을 때까지 반복



# 어려운 점

노드가 뭔데

트리가 뭔데

자료구조 좀 공부해야 알고리즘 공부가 되겠다...

# 배운 점


**포화 이진 트리란?**
- 모든 노드가 0개 또는 2개의 자식 노드를 가지는 트리
- 포화 이진 트리는 **노드 개수가 2^h - 1**인 트리만 가능


# 알고리즘

      String binNum = Long.toBinaryString(numbers[i]);
      int height = (int) Math.ceil(Math.log(binNum.length() + 1) / Math.log(2));
      int treeSize = (int) Math.pow(2, height) - 1;
      binNum = String.format("%" + treeSize + "s", binNum).replace(' ', '0');
      // treeSize가 될 때까지 앞에 0 추가: ("%7s", 10001) -> 0010001
