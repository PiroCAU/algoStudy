### 문제 이해
- 1*1 크기의 칸들로 이루어진 직사각형 격자 형태의 미로
  - 각 칸은 통로 또는 벽으로 이루어짐
  - 통로로 된 칸으로만 이동할 수 있음
  - 한 칸을 이동하는데 1초가 걸림
- 통로들 중 한 칸에는 미로를 빠져나가는 문이 있는데, 레버를 당겨서만 열 수 있음
  - 레버 또한 통로들 중 한 칸에 있음
  - 즉, 레버를 당긴 후 미로를 빠져나가는 문이 있는 칸으로 이동해야 함
  - 레버를 당기지 않아도 출구가 있는 칸을 지나갈 수 있음
- 최대한 빠르게 미로를 빠져나가는데 걸리는 시간은?
#### input & output
- input: 미로를 나타낸 문자열 배열 maps
  - maps
    - S: 시작 지점
    - E: 출구
    - L: 레버
    - O: 통로
    - X: 벽
- output: 미로를 탈출하는데 필요한 최소 시간 (만약 탈출할 수 없다면 -1)
---
### 고안 방식
- 미로 탈출 관련한 내용이니 백트래킹을 이용해야 하지 않을까?
- 백트래킹을 이용해야 하므로 DFS를 이용하자!
- DFS로 코드를 짜다가 오류를 못 잡겠어서 GPT에게 물어보니 BFS로 코드를 짜보라고 함..
- BFS로 처음 짰을 때에는 모든 경우의 수를 탐색하기에 시간초과가 발생했음
  -> 지금까지의 이동해온 거리를 저장하는 배열을 만들어서 더 짧게 갈 수 있는 거리가 있는지 확인하여 짧은 쪽을 선택하도록 변경
#### 최종 방식
- 이동 동선: S -> L -> E
  - 각 시작 지점을 알기 위해서 S 지점과 L 지점을 각각 변수에 저장해줌
- 레버가 있는 칸으로 bfs를 수행하고, 탈출 문까지 bfs를 수행하여 두 경로를 더함으로써 결과값 산출
- BFS
  - 매개변수: 현재 위치 row, col 좌표, 최종 목적지 칸 target
  - 각 칸까지의 이동해온 거리를 저장할 이차원 배열 dist (`MAX_VALUE`로 미리 초기화)
  - 지금까지 이동해온 칸의 좌표를 저장할 큐 queue
  - 만약 현재 위치가 target이라면 그 칸의 dist 즉, 거리를 반환
  - target이 아니라면 이동 가능한 다음 칸으로 이동함
    - 이때, 다음 칸에 이미 저장된 값(기존에 도달했던 거리)이 현재 칸에서 1칸 이동했을 때 걸리는 거리보다 크다면
      즉, 새로 계산한 경로가 기존보다 더 짧으면 업데이트하고, 큐에 추가