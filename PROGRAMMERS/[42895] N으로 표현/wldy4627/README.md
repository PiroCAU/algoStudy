### 고안 방식
- DP를 사용해야 한다는 것을 힌트로 시작 -> 어떻게 하면 큰 문제를 작은 문제로 해결할 수 있을지 고민
- N을 1개, 2개, 3개, ... 썼을 때 어떤 변화가 일어나는지 확인
  - 1개: N
  - 2개: NN, N+N, N-N, N*N, N/N
  - 3개: NNN, NN+N, NN-N, NN*N, NN/N, (N+N)+N, (N+N)-N, ..., (N/N)/N
- 위의 예시를 일반화를 했을 때 다음처럼 유추해낼 수 있었음
  - 1개: 1번 사용
  - 2개: 1번 사용 () 1번 사용
  - 3개: 1번 사용 () 2번 사용, 2번 사용 () 1번 사용
  - 4개: 1번 사용 () 3번 사용, 2번 사용 () 2번 사용, 3번 사용 () 1번 사용
- 위의 성질을 이용해서 이전에 계산해놓은 것들을 이용해서 다음 값들을 구하기로 함 -> DP 이용!

### 풀이 방식
- `List<Set<i>>`을 이용하여 `Set`에는 i개의 N을 이용하여 만들 수 있는 숫자들을 저장하고, 이러한 Set을 `List`로 관리
  - Set을 이용함으로써 중복된 값이 들어가지 않도록 하였음
- `dpList[i]의 원소  = dpList[j] (사칙연산) dpList[i - j]`라는 특징을 이용하여서 계산해줌
- dpList[i]의 원소들을 모두 계산한 이후에는 number를 담고 있는지 확인하여 있다면 반환
#### 시간 복잡도
- dpList 초기화 -> **O(1)**
- num 값 dpList에 추가 -> **O(8)**
- DP 연산 수행 -> **O(8 × 8 × M²)**
- 목표 숫자 확인 -> **O(8M)**
- 최종 시간 복잡도(최악):  **O(8³ × M²)**