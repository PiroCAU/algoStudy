### 문제 이해
- 라이언은 저번 양궁대회 우승자, 이번 대회 결승전 상대는 어피치
- 한 선수의 연속 우승보다는 다양한 선수들이 양궁 대회에서 우승하기를 원함 -> 결승전 규칙을 라이언에게 불리하게 설정
  1. 어피치가 화살 n발을 다 쏜 후 라이언이 화살 n발을 쏨
  2. 점수를 계산
     - 가장 작은 원의 과녁은 10점, 가장 큰 원의 바깥쪽은 0점
     - k(1~10)점을 어피치가 a발 맞추고, 라이언이 b발 맞추는 경우 더 많은 화살을 k점에 맞춘 선수가 k점을 가져감
       - a == b: 어피치가 k점을 가져감
       - a == b == 0: 어느 누구도 k점을 가져가지 않음
  3. 모든 과녁 점수에 대해 각 선수의 최종 점수 계싼
  4. 최종 점수가 더 높은 선수가 우승, 점수가 같은 경우 어피치가 우승
- 현재 상황: 어피치가 n발 모두 쏜 상황 -> 라이언이 화살을 쏠 차례
  - 라이언이 어피치를 큰 점수 차이로 이기기 위해 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지?
#### input & output
- input
  - 화살의 개수 n
  - 어피치가 맞힌 과녁 점수의 개수를 10점부터 0점까지 순서대로 담은 정수 배열 info
- output: 라이언이 가장 큰 점수 차이로 우승하기 위해 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지 10점부터 0점까지 순서대로 정수 배열 / 우승할 수 없는 경우 [-1] return
---
### 고안 방식
- DFS를 이용해야할까...?
#### 최종 방식
- 모든 점수를 다 봤거나, 화살을 다 썼으면 남은 화살은 0점으로
- 라이언이 어피치를 이긴 경우에만 answer을 갱신
  - 점수 차이가 더 클 경우 무조건 갱신
  - 점수 차이가 같다면 더 낮은 점수에 더 많은 화살을 쏜 경우를 선택
- 현재 점수에 화살을 쏘는 경우
  - 어파치보다 1발 더 쏘고 라이언이 점수 가져감
  - 남은 화살로 다음 점수 처리, 이후 백트래킹으로 원상복구
- 현재 점수에 아예 화살을 안 쏘는 경우
  - 해당 점수는 포기하고 다음 점수로 -> 어피치가 점수 가져감