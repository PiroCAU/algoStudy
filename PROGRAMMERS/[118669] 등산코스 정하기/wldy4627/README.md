### 문제 이해
- n개의 지점에는 1부터 n까지의 번호가 붙어있으며, 출입구, 쉼터, 혹은 산봉우리임
- 각 지점은 양방향 통행이 가능한 등산로로 연결되어 있으며, 서로 다른 지점을 이동할 때 이 등산로를 이용해야 함
- 등산로별로 이동하는데 일정 시간이 소요됨
> 1-2-3-2-1으로 표현하는 등산코스는 1번 지점에서 출발해 2번, 3번, 2번, 1번 지점을 순서대로 방문한다는 뜻
- 쉼터, 산봉우리를 방문할 때마다 휴식을 취할 수 있으며, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간을 intensity라고 부름
- 출입구 중 한 곳에서 출발해 산봉우리 중 한 곳만 방문한 뒤 원래의 출입구로 돌아오는 등산코스를 정하려고 함
- intensity가 최소가 되도록 등산코스를 정하려고 함
#### input & output
- input:
    - 지점 수 n
    - 각 등산로의 정보를 담은 2차원 정수 배열 paths
    - 출입구들의 번호가 담긴 정수 배열 gates
    - 산봉우리들의 번호가 담긴 정수 배열 summits
- output:
    - intensity가 최소가 되는 등산코스에 포함된 산봉우리 번호, intensity의 최솟값을 배열에 담아 return
    - intensity가 최소가 되는 등산코스가 여러 개라면 그중 산봉우리의 번호가 가장 낮은 등산코스
---
### 알고리즘 분류
- 그래프 탐색
#### 최종 방식
- `ArrayList<Node>[] graph`에 그래프 정보 양방향으로 넣기
- (gate -> summit)의 경로만 고려 -> 가장 최소 intensity 찾기
- 각 gate마다 다익스트라 수행 -> intensity 저장 -> summit 순회를 통한 최소 intensity 값 찾기