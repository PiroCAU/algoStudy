# BOJ 9935 - 문자열 폭발

https://www.acmicpc.net/problem/9935

## 📌 문제 개요
 - 문자열 S와 폭발 문자열 P가 주어진다.
 - 문자열 S를 왼쪽부터 차례로 읽으며, 부분 문자열이 폭발 문자열과 같아지는 순간 해당 부분을 제거한다.
 - 제거 후 문자열이 이어지면서 다시 폭발 문자열이 생길 수 있고, 이를 더 이상 제거할 수 없을 때까지 반복한다.
 - 최종적으로 남은 문자열을 출력한다.
 - 만약 아무 것도 남지 않으면 "FRULA"를 출력한다.

## ❌ 처음 시도한 풀이
 - 문자열 안에 폭발 문자열이 있는지 contains()로 확인 후, replace()로 제거를 반복.
 - 하지만 이 경우 문자열의 길이가 최대 1,000,000, 폭발 문자열의 길이가 최대 36이므로, 반복 탐색 및 복사로 인해 O(N × M × 반복횟수) → 사실상 O(N²) 에 가까운 시간복잡도가 발생.
 - 따라서 대용량 입력에서 시간 초과 발생.

## ✅ 효율적인 풀이 (스택 활용)
	1.	문자열을 왼쪽부터 한 글자씩 순회한다.
	2.	스택(StringBuilder 또는 char[])에 문자를 push 한다.
	3.	현재 문자가 폭발 문자열의 마지막 문자이고, 스택의 길이가 폭발 문자열 길이 이상일 때만 검사한다.
	4.	스택 끝에서 폭발 문자열 길이만큼 비교해서 일치하면 pop 한다.
	5.	최종적으로 스택에 남은 문자열이 답이 된다.
	6.	스택이 비어 있으면 "FRULA" 출력.

## 참고
 - 스택에 관련한 문제이더라도 반드시 스택 자료구조를 사용할 필요는 없고 ArrayList와 포인터 등을 사용해서 유사하게 사용할 수 있다. 