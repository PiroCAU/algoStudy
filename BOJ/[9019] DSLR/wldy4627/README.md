### 문제 이해
- D, S, L, R을 이용하는 간단한 계산기
- n의 네 자릿수를 d1, d2, d3, d4
  1. D: D는 n을 두 배로 바꿈 -> 결과 값이 9999보다 큰 경우 10000으로 나눈 나머지를 취함, 그 결과(2n mod 10000) 저장
  2. S: S는 n에서 1을 뺀 결과 n-1을 저장 -> n이 0이라면 9999가 저장됨
  3. L: L은 n의 각 자릿수를 왼편으로 회전시켜 그 결과를 저장 -> 네 자릿수: d2, d3, d4, d1
  4. R: R은 n의 각 자릿수를 오른편으로 회전시켜 그 결과를 저장 -> 네 자릿수: d4, d1, d2, d3
- 서로 다른 두 정수 A, B에 대하여 A를 B로 바꾸는 최소한의 명령어를 생성하는 프로그램
  - 1234 -(L)-> 2341 -(L)-> 3412
  - 1234 -(R)-> 4123 -(R)-> 3412
#### input & output
- input
    - 테스트 케이스 개수 T
    - T개의 테스트 케이스
      - A: 레지스터의 초기 값
      - B: 최종 값
- output: A에서 B로 변환하기 위해 필요한 최소한 명령어
---
### 고안 방식
- BFS로 먹을 수 있는 가장 가까운 물고기 탐색
#### 최종 방식
- 테스트 케이스 개수 T 저장
- T만큼 A와 B를 입력받은 후 bfs 진행
    - 현재 숫자 now에 대해서 DSLR 연산 수행
    - 각 연산 결과에 대해 해당 결과 숫자가 방문되지 않았으면,
      - 연산 경로를 현재까지의 경로 + 해당 연산 문자로 갱신
      - 큐에 추가하여 다음 단계 탐색 대상에 포함
    - 목표에 도달한다면 저장된 연산 경로 반환