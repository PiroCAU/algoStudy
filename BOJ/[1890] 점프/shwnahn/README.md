# 사고의 흐름
### 문제 요구사항
- N x N 게임판
- 각 칸에 적혀있는 숫자만큼 반드시 이동
- 이동 시마다 방향 선택 (1) 오른쪽 (2) 아래쪽
- 가장 왼쪽 위 칸에서 가장 오른쪽 아래 성공하는 개수 리턴

### 생각하기
이동 반복하는 식으로 구현

### 솔루션 (1)
- 이동하기 (반복)
    - n칸 이동할 수 있는지 확인
    - 이동할 수 없다면 false 리턴
    - 현재 위치가 오른쪽 끝이라면 count++
    1. 오른쪽으로 n칸 이동
    2. 아래쪽으로 n칸 이동

> 매모리 초과!

### 솔루션 (2)
'동적 계획법' 활용하기
- 새로운 grid를 만들어서, 기존 grid에서 각 칸 별로 도달가능한 경우의 수 저장
- 풀이 방식 자체는 비슷하지만, '경우의 수'를 저장하는 게 더 효율적
해결!

# 어려운 점
비효율, 효율의 경계 파악하기

# 배운 점
동적계획법은 '배운 것 써먹기' 로 이해가능하다

# 알고리즘
    public static long dfs(int r, int c) {
        // 1. 도착점일 경우
        if (r == N - 1 && c == N - 1) return 1;
    
        // 2. 이미 방문한 적이 있는 경우 dp값 리턴
        if (dp[r][c] != -1) return dp[r][c];
    
        // 3. 이동
        dp[r][c] = 0; // 방문이력 남기기
        int step = grid[r][c];
        // 3-1. 아래
        if (r + step < N) {
            dp[r][c] += dfs(r + step, c);
        }
        // 3-2. 오른쪽
        if (c + step < N) {
            dp[r][c] += dfs(r, c + step);
        }
    
        return dp[r][c]; // 경로의 수 리턴
    }
